#!/usr/bin/python3

# Form implementation generated from reading ui file 'remote_gardener.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets

# Imports
import time
import queue
import socket
import garden_pb2 as tool_shed
from google.protobuf.message import DecodeError
from datetime import timedelta
from datetime import datetime
from day_schedule import Ui_DaySchedule

# Connection variables
HOST = '192.168.1.178'
PORT = 50007
VERSION = '0.6'
ABOUT_STR = 'Remote Gardener v' + VERSION + ' created by Pablo Garcia Beltran (pablopgb.pgb@gmail.com)'
DEMO_MODE = True

# Create device list:
devs = {
    tool_shed.container.devices.DEV_ACT_PUMP,
    tool_shed.container.devices.DEV_ACT_VALVE,
    tool_shed.container.devices.DEV_SNS_TANK_FULL,
    tool_shed.container.devices.DEV_SNS_TANK_EMPTY,
    tool_shed.container.devices.DEV_SNS_WELL_EMPTY,
    tool_shed.container.devices.DEV_SNS_RAIN,
}

# Weekday index to string
day_map = {
    0: 'MONDAY',
    1: 'TUESDAY',
    2: 'WEDNESDAY',
    3: 'THURSDAY',
    4: 'FRIDAY',
    5: 'SATURDAY',
    6: 'SUNDAY'
}

############################################################################################
# Thread that handles sending
class Sender ( QtCore.QThread ):
    lost_conn = QtCore.pyqtSignal()

    def __init__ ( self, s, s_lock, q_out, q_out_lock ):
        QtCore.QThread.__init__( self )
        self.s = s
        self.s_lock = s_lock
        self.q_out = q_out
        self.q_out_lock = q_out_lock

    def run ( self ):
        print( 'Sender thread is running' )

        while True:
            # Check to see if we should kill thread
            if self.isInterruptionRequested():
                break

            self.q_out_lock.lock()
            if not self.q_out.empty():
                container = self.q_out.get()
                self.q_out_lock.unlock()
                data = container.SerializeToString()
                try:
                    self.s_lock.lock()
                    self.s.sendall( data )
                    time.sleep( 0.05 )

                except ( ConnectionAbortedError, ConnectionResetError, ConnectionRefusedError ):
                    self.lost_conn.emit()
                    break

                finally:
                    self.s_lock.unlock()
            else:
                self.q_out_lock.unlock()

        print( 'Sender thread shutting down' )
############################################################################################


############################################################################################
# Thread that handles receiving
class Receiver ( QtCore.QThread ):
    lost_conn = QtCore.pyqtSignal()
    server_alive = QtCore.pyqtSignal()

    def __init__ ( self, s, s_lock, q_in, q_in_lock ):
        QtCore.QThread.__init__( self )
        self.s = s
        self.s_lock = s_lock
        self.q_in = q_in
        self.q_in_lock = q_in_lock

    def run ( self ):
        print( 'Receiver thread is running' )

        while True:
            # Check to see if we should kill thread
            if self.isInterruptionRequested():
                break

            try:
                self.s_lock.lock()
                data = self.s.recv( 1024 )
                if data:
                    try:
                        container = tool_shed.container()
                        container.ParseFromString( data )
                        self.server_alive.emit()
                        self.q_in_lock.lock()
                        self.q_in.put( container )
                        self.q_in_lock.unlock()

                    except DecodeError:
                        print( 'Was not able to parse message!' )

            except BlockingIOError:
                continue

            except ( ConnectionAbortedError, ConnectionResetError, ConnectionRefusedError ):
                self.lost_conn.emit()
                break

            finally:
                self.s_lock.unlock()

        print( 'Receiver thread shutting down' )
############################################################################################


#######################################################################################################
# Create QtThread that will update the GUI
class UpdateMonitor ( QtCore.QThread ):
    device_update_signal = QtCore.pyqtSignal( [ int, bool ] )
    print_info_signal = QtCore.pyqtSignal( [ str ] )
    save_schedule = QtCore.pyqtSignal( [ list ] )

    def __init__ ( self, q_in, q_in_lock ):
        QtCore.QThread.__init__( self )
        self.q_in = q_in
        self.q_in_lock = q_in_lock

    def run ( self ):
        print( 'Updater monitor thread is running' )

        while True:
            # Check to see if we should kill thread
            if self.isInterruptionRequested():
                break

            self.q_in_lock.lock()
            if not self.q_in.empty():
                container = self.q_in.get()
                self.q_in_lock.unlock()
                
                if container.HasField( 'all_device_updates' ):
                    for dev_update in container.all_device_updates.updates:
                        self.device_update_signal.emit( dev_update.device, dev_update.status )

                elif container.HasField( 'next_watering_time' ):
                    dt = datetime.fromtimestamp( container.next_watering_time.timestamp.seconds )
                    td = timedelta( seconds=container.next_watering_time.duration.seconds )
                    msg = 'Next watering scheduled for ' + str( td ) + ' at ' + str( dt ) + ', scheduled daily: ' + str( container.next_watering_time.daily )
                    self.print_info_signal.emit( msg )

                elif container.HasField( 'all_watering_times' ):
                    self.print_info_signal.emit( 'WATERING SCHEDULE:' )
                    watering_times = [ x for x in container.all_watering_times.times ]
                    self.save_schedule.emit( watering_times )
                    watering_times.sort( key=lambda x:x.timestamp.seconds )
                    for watering_time in watering_times:
                        dt = datetime.fromtimestamp( watering_time.timestamp.seconds )
                        td = timedelta( seconds=watering_time.duration.seconds )
                        msg = ''
                        if watering_time.daily:
                            msg = msg + 'DAILY AT ' + str( dt.strftime( '%H:%M' ) ) + ' FOR ' + str( td.seconds // 60 ) + ' minute' + ( 's' if td.seconds // 60 > 1 else '' ) + ' starting on ' + str( dt.date() )
                        elif watering_time.weekly:
                            msg = msg + 'WEEKLY ON ' + day_map[ dt.date().weekday() ] + 'S AT ' + str( dt.strftime( '%H:%M' ) ) + ' FOR ' + str( td.seconds // 60 ) + ' minute'  + ( 's' if td.seconds // 60 > 1 else '' ) + ' starting on ' + str( dt.date() )
                        else:
                            msg = 'Watering scheduled for ' + str( td ) + ' at ' + str( dt )
                        self.print_info_signal.emit( msg )

                elif container.HasField( 'no_watering_times' ):
                    self.save_schedule.emit( [] )
                    self.print_info_signal.emit( 'No watering times scheduled!' )

                elif container.HasField( 'logs' ):
                    if container.logs == '':
                        self.print_info_signal.emit( 'No logs!' )
                    else:
                        self.print_info_signal.emit( 'LOGS:' )
                        self.print_info_signal.emit( container.logs[ :-1 ] )

            else:
                self.q_in_lock.unlock()

        print( 'The update monitor thread is shutting down' )
#######################################################################################################


############################################################
# Clickable label, used for secret demo mode sensor toggling
class QClickableLabel( QtWidgets.QLabel ):
    clicked = QtCore.pyqtSignal()

    def __init__ ( self, parent ):
        QtWidgets.QLabel.__init__( self, parent )

    def mousePressEvent( self, event ):
        self.clicked.emit()
############################################################


###################################################
# Wrap day schedule
class DaySchedule ( QtWidgets.QDialog ):
    def __init__ ( self, parent=None ):
        QtWidgets.QDialog.__init__( self, parent )
        self.ui = Ui_DaySchedule()
        self.ui.setupUi( self )
###################################################


############################################################################################
# Paintable label, used for painting days that have events
class QPaintableCalendarWidget( QtWidgets.QCalendarWidget ):
    print_info_signal = QtCore.pyqtSignal( [ str ] )
    schedule = []

    def __init__ ( self, parent ):
        QtWidgets.QCalendarWidget.__init__( self, parent )

    def set_schedule ( self, schedule ):
        self.schedule = schedule.copy()
        self.updateCells()

    def check_day( self, date ):
        dt_today = datetime.today()
        dt_clicked = datetime( year=date.year(), month=date.month(), day=date.day() )
        dt_clicked_date = dt_clicked.date()
        if dt_clicked_date >= dt_today.date() and self.schedule:
            time_list = []
            for watering_time in self.schedule:
                dt = datetime.fromtimestamp( watering_time.timestamp.seconds )
                td = timedelta( seconds=watering_time.duration.seconds )
                if dt_clicked_date >= dt.date():
                    if watering_time.weekly and dt.date().weekday() == ( date.dayOfWeek() - 1 ):
                        time_list.append( ( dt.time(), td.seconds ) )
                    elif watering_time.daily:
                        time_list.append( ( dt.time(), td.seconds ) )
                    elif dt.date() == dt_clicked.date():
                        time_list.append( ( dt.time(), td.seconds ) )
            
            if time_list:
                time_list.sort()
                self.print_info_signal.emit( 'WATERING SCHEDULE for ' + str( dt_clicked.date() ) + ':' )
                for time in time_list:
                    self.print_info_signal.emit( str( time[0].strftime( '%H:%M' ) ) + ' FOR ' + str( time[1] // 60 ) + ' minute' + ( 's' if time[1] // 60 > 1 else '' ) )

    def paintCell ( self, painter, rect, date ):
        dt_today = datetime.today()
        dt_painting = datetime( year=date.year(), month=date.month(), day=date.day() )
        dt_painting_date = dt_painting.date()
        super().paintCell( painter, rect, date )
        if dt_painting_date >= dt_today.date() and self.schedule:
            bg_color = QtGui.QColor( 'blue' )
            bg_color.setAlpha( 64 )
            bg_color_dark = QtGui.QColor( 'darkBlue' )
            bg_color_dark.setAlpha( 128 )
            painter.save()
            overrode = False
            num_of_watering_events = 0
            for watering_time in self.schedule:
                dt = datetime.fromtimestamp( watering_time.timestamp.seconds )
                if dt_painting_date >= dt.date():
                    if watering_time.weekly and dt.date().weekday() == ( date.dayOfWeek() - 1 ):
                        if dt_painting_date == dt.date():
                            overrode = True
                            super().paintCell( painter, rect, date )
                            painter.fillRect( rect, bg_color_dark )
                        elif not overrode:
                            overrode = True
                            painter.fillRect( rect, bg_color )
                        num_of_watering_events = num_of_watering_events + 1
                    elif watering_time.daily:
                        if dt_painting_date == dt.date():
                            overrode = True
                            super().paintCell( painter, rect, date )
                            painter.fillRect( rect, bg_color_dark )
                        if not overrode:
                            overrode = True
                            painter.fillRect( rect, bg_color )
                        num_of_watering_events = num_of_watering_events + 1
                    elif dt.date() == dt_painting.date():
                        if dt_painting_date == dt.date():
                            overrode = True
                            super().paintCell( painter, rect, date )
                            painter.fillRect( rect, bg_color_dark )
                        if not overrode:
                            overrode = True
                            painter.fillRect( rect, bg_color )
                        num_of_watering_events = num_of_watering_events + 1
            if num_of_watering_events:
                font = painter.font()
                font.setPointSize( 5 * font.pointSize() // 6 )
                font.setBold( True )
                font.setItalic( True )
                painter.setFont( font )
                painter.drawText( rect, 0, 'x' + str( num_of_watering_events ) )
            painter.restore()
############################################################################################


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(639, 731)
        MainWindow.setTabShape(QtWidgets.QTabWidget.TabShape.Triangular)
        MainWindow.setUnifiedTitleAndToolBarOnMac(True)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())
        self.centralwidget.setSizePolicy(sizePolicy)
        self.centralwidget.setObjectName("centralwidget")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.centralwidget)
        self.horizontalLayout_3.setSizeConstraint(QtWidgets.QLayout.SizeConstraint.SetDefaultConstraint)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.widget_controls = QtWidgets.QWidget(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Maximum, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_controls.sizePolicy().hasHeightForWidth())
        self.widget_controls.setSizePolicy(sizePolicy)
        self.widget_controls.setObjectName("widget_controls")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.widget_controls)
        self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.gb_connection = QtWidgets.QGroupBox(parent=self.widget_controls)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.gb_connection.sizePolicy().hasHeightForWidth())
        self.gb_connection.setSizePolicy(sizePolicy)
        self.gb_connection.setObjectName("gb_connection")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.gb_connection)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.lbl_host = QtWidgets.QLabel(parent=self.gb_connection)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lbl_host.sizePolicy().hasHeightForWidth())
        self.lbl_host.setSizePolicy(sizePolicy)
        self.lbl_host.setObjectName("lbl_host")
        self.gridLayout_2.addWidget(self.lbl_host, 0, 1, 1, 1)
        self.lbl_port = QtWidgets.QLabel(parent=self.gb_connection)
        self.lbl_port.setObjectName("lbl_port")
        self.gridLayout_2.addWidget(self.lbl_port, 2, 1, 1, 1)
        self.txt_port = QtWidgets.QLineEdit(parent=self.gb_connection)
        self.txt_port.setMaximumSize(QtCore.QSize(100, 16777215))
        self.txt_port.setObjectName("txt_port")
        self.gridLayout_2.addWidget(self.txt_port, 2, 2, 1, 1)
        self.txt_host = QtWidgets.QLineEdit(parent=self.gb_connection)
        self.txt_host.setMaximumSize(QtCore.QSize(100, 16777215))
        self.txt_host.setText("")
        self.txt_host.setObjectName("txt_host")
        self.gridLayout_2.addWidget(self.txt_host, 0, 2, 1, 1)
        self.btn_connect = QtWidgets.QPushButton(parent=self.gb_connection)
        self.btn_connect.setEnabled(True)
        self.btn_connect.setObjectName("btn_connect")
        self.gridLayout_2.addWidget(self.btn_connect, 3, 1, 1, 2)
        self.verticalLayout_3.addWidget(self.gb_connection)
        self.gb_watering = QtWidgets.QGroupBox(parent=self.widget_controls)
        self.gb_watering.setObjectName("gb_watering")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.gb_watering)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.gb_sched = QtWidgets.QGroupBox(parent=self.gb_watering)
        self.gb_sched.setObjectName("gb_sched")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.gb_sched)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.btn_get_sched = QtWidgets.QPushButton(parent=self.gb_sched)
        self.btn_get_sched.setObjectName("btn_get_sched")
        self.verticalLayout_4.addWidget(self.btn_get_sched)
        self.line_6 = QtWidgets.QFrame(parent=self.gb_sched)
        self.line_6.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line_6.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_6.setObjectName("line_6")
        self.verticalLayout_4.addWidget(self.line_6)
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.cb_sched_weekly = QtWidgets.QCheckBox(parent=self.gb_sched)
        self.cb_sched_weekly.setChecked(False)
        self.cb_sched_weekly.setAutoExclusive(False)
        self.cb_sched_weekly.setObjectName("cb_sched_weekly")
        self.horizontalLayout_5.addWidget(self.cb_sched_weekly)
        self.cb_sched_daily = QtWidgets.QCheckBox(parent=self.gb_sched)
        self.cb_sched_daily.setChecked(False)
        self.cb_sched_daily.setAutoExclusive(False)
        self.cb_sched_daily.setObjectName("cb_sched_daily")
        self.horizontalLayout_5.addWidget(self.cb_sched_daily)
        self.verticalLayout_4.addLayout(self.horizontalLayout_5)
        self.de_sched = QtWidgets.QDateEdit(parent=self.gb_sched)
        self.de_sched.setObjectName("de_sched")
        self.verticalLayout_4.addWidget(self.de_sched)
        self.te_sched = QtWidgets.QTimeEdit(parent=self.gb_sched)
        self.te_sched.setObjectName("te_sched")
        self.verticalLayout_4.addWidget(self.te_sched)
        self.widget_2 = QtWidgets.QWidget(parent=self.gb_sched)
        self.widget_2.setObjectName("widget_2")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.widget_2)
        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.lbl_sched_dur = QtWidgets.QLabel(parent=self.widget_2)
        self.lbl_sched_dur.setObjectName("lbl_sched_dur")
        self.horizontalLayout.addWidget(self.lbl_sched_dur)
        self.sb_sched_dur = QtWidgets.QSpinBox(parent=self.widget_2)
        self.sb_sched_dur.setMinimum(1)
        self.sb_sched_dur.setProperty("value", 1)
        self.sb_sched_dur.setObjectName("sb_sched_dur")
        self.horizontalLayout.addWidget(self.sb_sched_dur)
        self.lbl_sched_dur_units = QtWidgets.QLabel(parent=self.widget_2)
        self.lbl_sched_dur_units.setObjectName("lbl_sched_dur_units")
        self.horizontalLayout.addWidget(self.lbl_sched_dur_units)
        self.verticalLayout_4.addWidget(self.widget_2)
        self.btn_sched = QtWidgets.QPushButton(parent=self.gb_sched)
        self.btn_sched.setObjectName("btn_sched")
        self.verticalLayout_4.addWidget(self.btn_sched)
        self.btn_unsched = QtWidgets.QPushButton(parent=self.gb_sched)
        self.btn_unsched.setObjectName("btn_unsched")
        self.verticalLayout_4.addWidget(self.btn_unsched)
        self.verticalLayout_2.addWidget(self.gb_sched)
        self.widget_3 = QtWidgets.QWidget(parent=self.gb_watering)
        self.widget_3.setObjectName("widget_3")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.widget_3)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.lbl_water_dur = QtWidgets.QLabel(parent=self.widget_3)
        self.lbl_water_dur.setObjectName("lbl_water_dur")
        self.horizontalLayout_2.addWidget(self.lbl_water_dur)
        self.sb_water_dur = QtWidgets.QSpinBox(parent=self.widget_3)
        self.sb_water_dur.setMinimum(1)
        self.sb_water_dur.setObjectName("sb_water_dur")
        self.horizontalLayout_2.addWidget(self.sb_water_dur)
        self.lbl_water_dur_units = QtWidgets.QLabel(parent=self.widget_3)
        self.lbl_water_dur_units.setObjectName("lbl_water_dur_units")
        self.horizontalLayout_2.addWidget(self.lbl_water_dur_units)
        self.cb_water_dur = QtWidgets.QCheckBox(parent=self.widget_3)
        self.cb_water_dur.setText("")
        self.cb_water_dur.setChecked(False)
        self.cb_water_dur.setObjectName("cb_water_dur")
        self.horizontalLayout_2.addWidget(self.cb_water_dur)
        self.verticalLayout_2.addWidget(self.widget_3)
        self.btn_start_water = QtWidgets.QPushButton(parent=self.gb_watering)
        self.btn_start_water.setObjectName("btn_start_water")
        self.verticalLayout_2.addWidget(self.btn_start_water)
        self.btn_stop_water = QtWidgets.QPushButton(parent=self.gb_watering)
        self.btn_stop_water.setObjectName("btn_stop_water")
        self.verticalLayout_2.addWidget(self.btn_stop_water)
        self.verticalLayout_3.addWidget(self.gb_watering)
        self.gb_pumping = QtWidgets.QGroupBox(parent=self.widget_controls)
        self.gb_pumping.setObjectName("gb_pumping")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.gb_pumping)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.widget_4 = QtWidgets.QWidget(parent=self.gb_pumping)
        self.widget_4.setObjectName("widget_4")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout(self.widget_4)
        self.horizontalLayout_4.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.lbl_pump_dur = QtWidgets.QLabel(parent=self.widget_4)
        self.lbl_pump_dur.setObjectName("lbl_pump_dur")
        self.horizontalLayout_4.addWidget(self.lbl_pump_dur)
        self.sb_pump_dur = QtWidgets.QSpinBox(parent=self.widget_4)
        self.sb_pump_dur.setMinimum(1)
        self.sb_pump_dur.setProperty("value", 1)
        self.sb_pump_dur.setObjectName("sb_pump_dur")
        self.horizontalLayout_4.addWidget(self.sb_pump_dur)
        self.lbl_pump_dur_units = QtWidgets.QLabel(parent=self.widget_4)
        self.lbl_pump_dur_units.setObjectName("lbl_pump_dur_units")
        self.horizontalLayout_4.addWidget(self.lbl_pump_dur_units)
        self.cb_pump_dur = QtWidgets.QCheckBox(parent=self.widget_4)
        self.cb_pump_dur.setText("")
        self.cb_pump_dur.setChecked(False)
        self.cb_pump_dur.setObjectName("cb_pump_dur")
        self.horizontalLayout_4.addWidget(self.cb_pump_dur)
        self.verticalLayout_5.addWidget(self.widget_4)
        self.btn_start_pump = QtWidgets.QPushButton(parent=self.gb_pumping)
        self.btn_start_pump.setObjectName("btn_start_pump")
        self.verticalLayout_5.addWidget(self.btn_start_pump)
        self.btn_stop_pump = QtWidgets.QPushButton(parent=self.gb_pumping)
        self.btn_stop_pump.setObjectName("btn_stop_pump")
        self.verticalLayout_5.addWidget(self.btn_stop_pump)
        self.verticalLayout_3.addWidget(self.gb_pumping)
        self.gb_misc = QtWidgets.QGroupBox(parent=self.widget_controls)
        self.gb_misc.setObjectName("gb_misc")
        self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.gb_misc)
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.btn_log = QtWidgets.QPushButton(parent=self.gb_misc)
        self.btn_log.setObjectName("btn_log")
        self.verticalLayout_8.addWidget(self.btn_log)
        self.btn_about = QtWidgets.QPushButton(parent=self.gb_misc)
        self.btn_about.setObjectName("btn_about")
        self.verticalLayout_8.addWidget(self.btn_about)
        self.verticalLayout_3.addWidget(self.gb_misc)
        self.horizontalLayout_3.addWidget(self.widget_controls)
        self.widget_status = QtWidgets.QWidget(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_status.sizePolicy().hasHeightForWidth())
        self.widget_status.setSizePolicy(sizePolicy)
        self.widget_status.setObjectName("widget_status")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.widget_status)
        self.verticalLayout_6.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.gb_status = QtWidgets.QGroupBox(parent=self.widget_status)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.gb_status.sizePolicy().hasHeightForWidth())
        self.gb_status.setSizePolicy(sizePolicy)
        self.gb_status.setObjectName("gb_status")
        self.gridLayout = QtWidgets.QGridLayout(self.gb_status)
        self.gridLayout.setObjectName("gridLayout")
        self.widget = QtWidgets.QWidget(parent=self.gb_status)
        self.widget.setObjectName("widget")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.widget)
        self.gridLayout_3.setContentsMargins(0, 0, 0, -1)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.lbl_tank_empty = QtWidgets.QLabel(parent=self.widget)
        self.lbl_tank_empty.setObjectName("lbl_tank_empty")
        self.gridLayout_3.addWidget(self.lbl_tank_empty, 6, 0, 1, 1)
        self.lbl_pump_status_disp = QtWidgets.QLabel(parent=self.widget)
        self.lbl_pump_status_disp.setMinimumSize(QtCore.QSize(50, 0))
        self.lbl_pump_status_disp.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.lbl_pump_status_disp.setObjectName("lbl_pump_status_disp")
        self.gridLayout_3.addWidget(self.lbl_pump_status_disp, 0, 1, 1, 1)
        self.line_4 = QtWidgets.QFrame(parent=self.widget)
        self.line_4.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_4.setObjectName("line_4")
        self.gridLayout_3.addWidget(self.line_4, 7, 0, 1, 2)
        self.lbl_valve_status = QtWidgets.QLabel(parent=self.widget)
        self.lbl_valve_status.setObjectName("lbl_valve_status")
        self.gridLayout_3.addWidget(self.lbl_valve_status, 2, 0, 1, 1)
        self.lbl_tank_empty_disp = QClickableLabel(parent=self.widget)
        self.lbl_tank_empty_disp.setMinimumSize(QtCore.QSize(50, 0))
        self.lbl_tank_empty_disp.setObjectName("lbl_tank_empty_disp")
        self.gridLayout_3.addWidget(self.lbl_tank_empty_disp, 6, 1, 1, 1)
        self.lbl_tank_full = QtWidgets.QLabel(parent=self.widget)
        self.lbl_tank_full.setObjectName("lbl_tank_full")
        self.gridLayout_3.addWidget(self.lbl_tank_full, 4, 0, 1, 1)
        self.line = QtWidgets.QFrame(parent=self.widget)
        self.line.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line.setObjectName("line")
        self.gridLayout_3.addWidget(self.line, 1, 0, 1, 2)
        self.lbl_tank_full_disp = QClickableLabel(parent=self.widget)
        self.lbl_tank_full_disp.setMinimumSize(QtCore.QSize(50, 0))
        self.lbl_tank_full_disp.setObjectName("lbl_tank_full_disp")
        self.gridLayout_3.addWidget(self.lbl_tank_full_disp, 4, 1, 1, 1)
        self.line_3 = QtWidgets.QFrame(parent=self.widget)
        self.line_3.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_3.setObjectName("line_3")
        self.gridLayout_3.addWidget(self.line_3, 5, 0, 1, 2)
        self.lbl_rain_disp = QClickableLabel(parent=self.widget)
        self.lbl_rain_disp.setMinimumSize(QtCore.QSize(50, 0))
        self.lbl_rain_disp.setObjectName("lbl_rain_disp")
        self.gridLayout_3.addWidget(self.lbl_rain_disp, 10, 1, 1, 1)
        self.lbl_well_empty_disp = QClickableLabel(parent=self.widget)
        self.lbl_well_empty_disp.setMinimumSize(QtCore.QSize(50, 0))
        self.lbl_well_empty_disp.setObjectName("lbl_well_empty_disp")
        self.gridLayout_3.addWidget(self.lbl_well_empty_disp, 8, 1, 1, 1)
        self.lbl_well_empty = QtWidgets.QLabel(parent=self.widget)
        self.lbl_well_empty.setObjectName("lbl_well_empty")
        self.gridLayout_3.addWidget(self.lbl_well_empty, 8, 0, 1, 1)
        self.lbl_valve_status_disp = QtWidgets.QLabel(parent=self.widget)
        self.lbl_valve_status_disp.setMinimumSize(QtCore.QSize(50, 0))
        self.lbl_valve_status_disp.setObjectName("lbl_valve_status_disp")
        self.gridLayout_3.addWidget(self.lbl_valve_status_disp, 2, 1, 1, 1)
        self.line_2 = QtWidgets.QFrame(parent=self.widget)
        self.line_2.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_2.setObjectName("line_2")
        self.gridLayout_3.addWidget(self.line_2, 3, 0, 1, 2)
        self.lbl_pump_status = QtWidgets.QLabel(parent=self.widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Maximum, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lbl_pump_status.sizePolicy().hasHeightForWidth())
        self.lbl_pump_status.setSizePolicy(sizePolicy)
        self.lbl_pump_status.setObjectName("lbl_pump_status")
        self.gridLayout_3.addWidget(self.lbl_pump_status, 0, 0, 1, 1)
        self.lbl_rain = QtWidgets.QLabel(parent=self.widget)
        self.lbl_rain.setObjectName("lbl_rain")
        self.gridLayout_3.addWidget(self.lbl_rain, 10, 0, 1, 1)
        self.line_5 = QtWidgets.QFrame(parent=self.widget)
        self.line_5.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line_5.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_5.setObjectName("line_5")
        self.gridLayout_3.addWidget(self.line_5, 9, 0, 1, 2)
        self.gridLayout.addWidget(self.widget, 1, 0, 1, 1)
        self.verticalLayout_6.addWidget(self.gb_status)
        self.gb_calendar = QtWidgets.QGroupBox(parent=self.widget_status)
        self.gb_calendar.setObjectName("gb_calendar")
        self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.gb_calendar)
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.cw_schedule = QPaintableCalendarWidget(parent=self.gb_calendar)
        self.cw_schedule.setGridVisible(True)
        self.cw_schedule.setVerticalHeaderFormat(QtWidgets.QCalendarWidget.VerticalHeaderFormat.NoVerticalHeader)
        self.cw_schedule.setNavigationBarVisible(True)
        self.cw_schedule.setDateEditEnabled(False)
        self.cw_schedule.setObjectName("cw_schedule")
        self.verticalLayout_9.addWidget(self.cw_schedule)
        self.verticalLayout_6.addWidget(self.gb_calendar)
        self.gb_output = QtWidgets.QGroupBox(parent=self.widget_status)
        self.gb_output.setObjectName("gb_output")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.gb_output)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.scrollArea = QtWidgets.QScrollArea(parent=self.gb_output)
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName("scrollArea")
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 453, 222))
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
        self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.scrollAreaWidgetContents)
        self.verticalLayout_7.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.text_output = QtWidgets.QTextEdit(parent=self.scrollAreaWidgetContents)
        self.text_output.setReadOnly(True)
        self.text_output.setObjectName("text_output")
        self.verticalLayout_7.addWidget(self.text_output)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.verticalLayout.addWidget(self.scrollArea)
        self.verticalLayout_6.addWidget(self.gb_output)
        self.horizontalLayout_3.addWidget(self.widget_status)
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        print( self.cw_schedule.paintCell )

        # Create palettes used to color labels
        self.green = QtGui.QPalette()
        self.green.setColor( QtGui.QPalette.ColorRole.WindowText, QtGui.QColor( 'green' ) )
        self.red = QtGui.QPalette()
        self.red.setColor( QtGui.QPalette.ColorRole.WindowText, QtGui.QColor( 'red' ) )

        # Set up device to widget map
        self.dev_map = {
            tool_shed.container.devices.DEV_ACT_PUMP: ( self.lbl_pump_status, self.lbl_pump_status_disp ),
            tool_shed.container.devices.DEV_ACT_VALVE: ( self.lbl_valve_status, self.lbl_valve_status_disp ),
            tool_shed.container.devices.DEV_SNS_TANK_FULL: ( self.lbl_tank_full, self.lbl_tank_full_disp ),
            tool_shed.container.devices.DEV_SNS_TANK_EMPTY: ( self.lbl_tank_empty, self.lbl_tank_empty_disp ),
            tool_shed.container.devices.DEV_SNS_WELL_EMPTY: ( self.lbl_well_empty, self.lbl_well_empty_disp ),
            tool_shed.container.devices.DEV_SNS_RAIN: ( self.lbl_rain, self.lbl_rain_disp ),
        }

        # Initialize the time of day
        dt = datetime.today()
        date = QtCore.QDate()
        date.setDate( dt.year, dt.month, dt.day )
        time = QtCore.QTime()
        time.setHMS( dt.hour, dt.minute, dt.second, int( dt.microsecond / 1000 ) )
        self.de_sched.setDate( date )
        self.te_sched.setTime( time )

        # Set the HOST and PORT default text
        self.txt_host.setText( HOST )
        self.txt_port.setText( str( PORT ) )

        # Disable the control interfaces until we have a connection
        self.gb_watering.setEnabled( False )
        self.gb_pumping.setEnabled( False )
        self.gb_status.setEnabled( False )
        self.gb_calendar.setEnabled( False )
        self.btn_log.setEnabled( False )

        # Set up queues and queue locks
        self.q_in = queue.Queue()
        self.q_in_lock = QtCore.QMutex()
        self.q_out = queue.Queue()
        self.q_out_lock = QtCore.QMutex()

        # Create comm lock
        self.s_lock = QtCore.QMutex()

        # Set up thread to signal updates to GUI
        self.updater = UpdateMonitor( self.q_in, self.q_in_lock )
        self.updater.device_update_signal.connect( self.device_update )
        self.updater.print_info_signal.connect( self.text_output.append )
        self.updater.save_schedule.connect( self.save_schedule )
        self.updater.start()

        # Connect connect button to slot
        self.btn_connect.pressed.connect( self.connect )

        # Connect about button to slot
        self.btn_about.pressed.connect( self.about )

        # Connect get schedule button to slot
        self.btn_get_sched.pressed.connect( self.get_schedule )

        # Connect schedule watering button to slot
        self.btn_sched.pressed.connect( self.schedule_watering )

        # Connect unschedule watering button to slot
        self.btn_unsched.pressed.connect( self.unschedule_watering )

        # Connect start watering button to slot
        self.btn_start_water.pressed.connect( self.start_watering )

        # Connect stop watering button to slot
        self.btn_stop_water.pressed.connect( self.stop_watering )

        # Connect start pumping button to slot
        self.btn_start_pump.pressed.connect( self.start_pumping )

        # Connect stop pumping button to slot
        self.btn_stop_pump.pressed.connect( self.stop_pumping )

        # Connect peak event log button to slot
        self.btn_log.pressed.connect( self.peak_event_log )

        # Make scheduling checkboxes self exclusive
        self.cb_sched_daily.clicked.connect( lambda checked : self.cb_sched_weekly.setChecked( False ) if checked else None )
        self.cb_sched_weekly.clicked.connect( lambda checked : self.cb_sched_daily.setChecked( False ) if checked else None )

        # Sync calendar and date edit connection
        self.de_sched.dateChanged.connect( self.sync_date_edit_onto_calendar )
        self.cw_schedule.selectionChanged.connect( self.sync_calendar_onto_date_edit )

        # Connect calendar signals
        self.cw_schedule.activated.connect( self.cw_schedule.check_day )
        self.cw_schedule.activated.connect( self.day_schedule_popup )
        self.cw_schedule.print_info_signal.connect( self.text_output.append )

        # Set 24 hour format for time edit
        self.te_sched.setDisplayFormat( 'HH:mm' )

        # Set background color of navigation bar of calendar
        self.cw_schedule.setStyleSheet( "QCalendarWidget  QWidget#qt_calendar_navigationbar"
                                        "{"
                                        "background-color : darkGray;"
                                        "}"
                                        "QCalendarWidget  QWidget# qt_calendar_navigationbar::hover"
                                        "{"
                                        "background-color : darkGray;"
                                        "}" ) 

        # Hook up sensor overrides if demo mode
        if DEMO_MODE:
            self.lbl_tank_full_disp.clicked.connect( lambda: self.toggle_sensor( tool_shed.container.devices.DEV_SNS_TANK_FULL, self.lbl_tank_full_disp ) )
            self.lbl_tank_empty_disp.clicked.connect( lambda: self.toggle_sensor( tool_shed.container.devices.DEV_SNS_TANK_EMPTY, self.lbl_tank_empty_disp ) )
            self.lbl_well_empty_disp.clicked.connect( lambda: self.toggle_sensor( tool_shed.container.devices.DEV_SNS_WELL_EMPTY, self.lbl_well_empty_disp ) )
            self.lbl_rain_disp.clicked.connect( lambda: self.toggle_sensor( tool_shed.container.devices.DEV_SNS_RAIN, self.lbl_rain_disp ) )

        self.about()

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Remote Gardener"))
        self.gb_connection.setTitle(_translate("MainWindow", "Connection"))
        self.lbl_host.setText(_translate("MainWindow", "Host:"))
        self.lbl_port.setText(_translate("MainWindow", "Port:"))
        self.btn_connect.setText(_translate("MainWindow", "Connect"))
        self.gb_watering.setTitle(_translate("MainWindow", "Watering"))
        self.gb_sched.setTitle(_translate("MainWindow", "Scheduling"))
        self.btn_get_sched.setText(_translate("MainWindow", "Get Schedule"))
        self.cb_sched_weekly.setText(_translate("MainWindow", "Weekly"))
        self.cb_sched_daily.setText(_translate("MainWindow", "Daily"))
        self.lbl_sched_dur.setText(_translate("MainWindow", "Duration:"))
        self.lbl_sched_dur_units.setText(_translate("MainWindow", "min"))
        self.btn_sched.setText(_translate("MainWindow", "Schedule"))
        self.btn_unsched.setText(_translate("MainWindow", "Unschedule"))
        self.lbl_water_dur.setText(_translate("MainWindow", "Duration"))
        self.lbl_water_dur_units.setText(_translate("MainWindow", "min"))
        self.btn_start_water.setText(_translate("MainWindow", "Start"))
        self.btn_stop_water.setText(_translate("MainWindow", "Stop"))
        self.gb_pumping.setTitle(_translate("MainWindow", "Pumping"))
        self.lbl_pump_dur.setText(_translate("MainWindow", "Duration"))
        self.lbl_pump_dur_units.setText(_translate("MainWindow", "min"))
        self.btn_start_pump.setText(_translate("MainWindow", "Start"))
        self.btn_stop_pump.setText(_translate("MainWindow", "Stop"))
        self.gb_misc.setTitle(_translate("MainWindow", "Miscellaneous"))
        self.btn_log.setText(_translate("MainWindow", "Event Log"))
        self.btn_about.setText(_translate("MainWindow", "About"))
        self.gb_status.setTitle(_translate("MainWindow", "Status"))
        self.lbl_tank_empty.setText(_translate("MainWindow", "Tank empty sensor status:"))
        self.lbl_pump_status_disp.setText(_translate("MainWindow", "UNKNOWN"))
        self.lbl_valve_status.setText(_translate("MainWindow", "Valve status:"))
        self.lbl_tank_empty_disp.setText(_translate("MainWindow", "UNKNOWN"))
        self.lbl_tank_full.setText(_translate("MainWindow", "Tank full sensor status:"))
        self.lbl_tank_full_disp.setText(_translate("MainWindow", "UNKNOWN"))
        self.lbl_rain_disp.setText(_translate("MainWindow", "UNKNOWN"))
        self.lbl_well_empty_disp.setText(_translate("MainWindow", "UNKNOWN"))
        self.lbl_well_empty.setText(_translate("MainWindow", "Well empty sensor status:"))
        self.lbl_valve_status_disp.setText(_translate("MainWindow", "UNKNOWN"))
        self.lbl_pump_status.setText(_translate("MainWindow", "Pump status:"))
        self.lbl_rain.setText(_translate("MainWindow", "Rain sensor status:"))
        self.gb_calendar.setTitle(_translate("MainWindow", "Schedule"))
        self.gb_output.setTitle(_translate("MainWindow", "Output"))

    def device_update ( self, device, status ):
        self.dev_map[ device ][ 1 ].setText( 'ACTIVE' if status else 'INACTIVE' )
        if status:
            self.dev_map[ device ][ 1 ].setPalette( self.green )
        else:
            self.dev_map[ device ][ 1 ].setPalette( self.red )

    def connect ( self ):
        try:
            host = self.txt_host.text()
            port = int( self.txt_port.text() )
            self.s = socket.socket( socket.AF_INET, socket.SOCK_STREAM )
            self.s.settimeout( 0.5 )
            self.s.connect( ( host, port ) )
            self.s.settimeout( None )
            self.s.setblocking( 0 )

            # Create comm threads
            self.sender = Sender( self.s, self.s_lock, self.q_out, self.q_out_lock )
            self.receiver = Receiver( self.s, self.s_lock, self.q_in, self.q_in_lock )
            self.heartbeat = QtCore.QTimer()
            self.pulse_mon = QtCore.QTimer()
            self.pulse_mon.setSingleShot( True )

            # Connect signals for threads
            self.sender.lost_conn.connect( self.disconnect )
            self.receiver.lost_conn.connect( self.disconnect )
            self.receiver.server_alive.connect( self.postpone_pulse_mon )
            self.heartbeat.timeout.connect( self.get_device_updates )
            self.pulse_mon.timeout.connect( self.disconnect )

            # Start comms threads
            self.sender.start()
            self.receiver.start()
            self.heartbeat.start( 250 )
            self.pulse_mon.start( 5000 )

            # If none of that raised an exception then we connected
            self.gb_connection.setEnabled( False )
            self.gb_watering.setEnabled( True )
            self.gb_pumping.setEnabled( True )
            self.gb_status.setEnabled( True )
            self.gb_calendar.setEnabled( True )
            self.btn_log.setEnabled( True )

            # Get device updates
            self.get_device_updates()

            # Get watering schedule
            self.get_schedule()

        except ValueError:
            self.text_output.append( 'Port is not an integer' )

        except TimeoutError:
            self.text_output.append( 'Failed to connect to host' )

        except ConnectionRefusedError:
            self.text_output.append( 'Connection was refused' )

    def disconnect ( self ):
        # Stop timers
        self.heartbeat.stop()

        # Request comms threads stop
        self.sender.requestInterruption()
        self.receiver.requestInterruption()

        # Wait until they have stopped
        self.sender.wait()
        self.receiver.wait()

        # Disabled the interfaces for the gardener and re-enable the connection menu
        self.gb_connection.setEnabled( True )
        self.gb_watering.setEnabled( False )
        self.gb_pumping.setEnabled( False )
        self.gb_status.setEnabled( False )
        self.gb_calendar.setEnabled( False )
        self.btn_log.setEnabled( False )

        # Reset queues
        def empty_queue ( q ):
            while not q.empty():
                try:
                    q.get_nowait()
                except queue.Empty:
                    break
        
        self.q_in_lock.lock()
        empty_queue( self.q_in )
        self.q_in_lock.unlock()
        self.q_out_lock.lock()
        empty_queue( self.q_out )
        self.q_out_lock.unlock()

        # Shutdown and close connection, we
        # don't have to use s_lock because
        # we already joined sender_thread
        self.s.close()

    def about ( self ):
        self.text_output.append( ABOUT_STR )

    def get_device_updates ( self ):
        container = tool_shed.container()
        container.get_device_updates = 1
        self.q_out_enqueue( container )

    def get_schedule ( self ):
        container = tool_shed.container()
        container.get_watering_times = 1
        self.q_out_enqueue( container )

    def schedule_watering ( self ):
        daily = self.cb_sched_daily.isChecked()
        weekly = self.cb_sched_weekly.isChecked()
        date = self.de_sched.date()
        time = self.te_sched.time()
        duration = self.sb_sched_dur.value()
        dt = datetime( year=date.year(), month=date.month(), day=date.day(), hour=time.hour(), minute=time.minute() )
        td = timedelta( minutes=duration )
        container = tool_shed.container()
        container.set_watering_time.timestamp.seconds = int( dt.timestamp() )
        container.set_watering_time.duration.FromTimedelta( td )
        if daily:
            container.set_watering_time.daily = daily
        elif weekly:
            container.set_watering_time.weekly = weekly
        self.q_out_enqueue( container )
        self.get_schedule()

    def unschedule_watering ( self ):
        daily = self.cb_sched_daily.isChecked()
        weekly = self.cb_sched_weekly.isChecked()
        date = self.de_sched.date()
        time = self.te_sched.time()
        duration = self.sb_sched_dur.value()
        dt = datetime( year=date.year(), month=date.month(), day=date.day(), hour=time.hour(), minute=time.minute() )
        td = timedelta( minutes=duration )
        container = tool_shed.container()
        container.cancel_watering_time.timestamp.seconds = int( dt.timestamp() )
        container.cancel_watering_time.duration.FromTimedelta( td )
        if daily:
            container.cancel_watering_time.daily = daily
        elif weekly:
            container.cancel_watering_time.weekly = weekly
        self.q_out_enqueue( container )
        self.get_schedule()

    def start_watering ( self ):
        duration = self.sb_water_dur.value() if self.cb_water_dur.isChecked() else 0
        td = timedelta( minutes=duration )
        container = tool_shed.container()
        container.water_now.duration.FromTimedelta( td )
        self.q_out_enqueue( container )

    def stop_watering ( self ):
        container = tool_shed.container()
        container.stop_watering = 1
        self.q_out_enqueue( container )

    def start_pumping ( self ):
        duration = self.sb_pump_dur.value() if self.cb_pump_dur.isChecked() else 0
        td = timedelta( minutes=duration )
        container = tool_shed.container()
        container.pump_now.duration.FromTimedelta( td )
        self.q_out_enqueue( container )

    def stop_pumping ( self ):
        container = tool_shed.container()
        container.stop_pumping = 1
        self.q_out_enqueue( container )

    def peak_event_log ( self ):
        container = tool_shed.container()
        container.peak_event_log = 10
        self.q_out_enqueue( container )

    def toggle_sensor( self, sensor, lbl ):
        status = None
        if lbl.text() == 'ACTIVE':
            status = False
        elif lbl.text() == 'INACTIVE':
            status = True
        else:
            return
            
        container = tool_shed.container()
        container.sensor_override.device = sensor
        container.sensor_override.status = status
        self.q_out_enqueue( container )

    def save_schedule ( self, schedule ):
        self.cw_schedule.set_schedule( schedule )

    def q_out_enqueue ( self, container ):
        self.q_out_lock.lock()
        self.q_out.put( container )
        self.q_out_lock.unlock()

    def postpone_pulse_mon ( self ):
        if self.pulse_mon.isActive():
            self.pulse_mon.start( 5000 )

    def sync_date_edit_onto_calendar ( self ):
        de_date = self.de_sched.date()
        cw_date = self.cw_schedule.selectedDate()
        if de_date != cw_date:
            self.cw_schedule.setSelectedDate( de_date )

    def sync_calendar_onto_date_edit ( self ):
        de_date = self.de_sched.date()
        cw_date = self.cw_schedule.selectedDate()
        if de_date != cw_date:
            self.de_sched.setDate( cw_date )

    def day_schedule_popup ( self, self.centralwidget ):
        popup = DaySchedule( self.centralwidget )
        popup.exec()


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec())
