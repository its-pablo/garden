# Form implementation generated from reading ui file 'remote_gardener.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets

# Imports
import time
import queue
import socket
import garden_pb2 as tool_shed
from google.protobuf.message import DecodeError
from datetime import timedelta
from datetime import datetime
from day_schedule import Ui_DaySchedule

# Connection variables
HOST = '192.168.1.178'
PORT = 50007
VERSION = '0.7'
ABOUT_STR = 'Remote Gardener v' + VERSION + ' created by Pablo Garcia Beltran (pablopgb.pgb@gmail.com)'
DEMO_MODE = True

# Create device list:
devs = {
    tool_shed.container.devices.DEV_ACT_PUMP,
    tool_shed.container.devices.DEV_ACT_VALVE,
    tool_shed.container.devices.DEV_SNS_TANK_FULL,
    tool_shed.container.devices.DEV_SNS_TANK_EMPTY,
    tool_shed.container.devices.DEV_SNS_WELL_EMPTY,
    tool_shed.container.devices.DEV_SNS_RAIN,
}

# Weekday index to string
day_map = {
    0: 'Monday',
    1: 'Tuesday',
    2: 'Wednesday',
    3: 'Thursday',
    4: 'Friday',
    5: 'Saturday',
    6: 'Sunday'
}

def is_watering_scheduled ( date_to_check, schedule ):
    # Is date in the past?
    dt_today = datetime.today()
    date_today = dt_today.date()
    if date_to_check < date_today:
        return ( [], False )

    times = []
    origin = False
    for watering_time in schedule:
        dt = datetime.fromtimestamp( watering_time.timestamp.seconds )
        dt_date = dt.date()
        td_period = timedelta( seconds=watering_time.period.seconds )
        # Is this watering time not expired?
        if dt >= dt_today:
            td_0 = timedelta()
            # Is this watering time on the date to check?
            if date_to_check == dt_date:
                times.append( watering_time )
                origin = True
            elif date_to_check > dt_date and td_period > td_0:
                td_between = date_to_check - dt_date
                # Check if time between events a multiple of the period
                if td_between % td_period == td_0:
                    times.append( watering_time )

    return ( times, origin )

def are_schedules_same ( schedule_a, schedule_b ):
    if ( schedule_a is None and schedule_b is not None ) or ( schedule_a is not None and schedule_b is None ):
        return False
    if schedule_a is None and schedule_b is None:
        return True
    for wt_a, wt_b in zip( schedule_a, schedule_b ):
        if wt_a.timestamp.seconds != wt_b.timestamp.seconds:
            return False
        elif wt_a.duration.seconds != wt_b.duration.seconds:
            return False
        elif wt_a.period.seconds != wt_b.period.seconds:
            return False
    return len( schedule_a ) == len( schedule_b )
        

############################################################################################
# Thread that handles sending
class Sender ( QtCore.QThread ):
    lost_conn = QtCore.pyqtSignal()

    def __init__ ( self, s, s_lock, q_out, q_out_lock ):
        QtCore.QThread.__init__( self )
        self.s = s
        self.s_lock = s_lock
        self.q_out = q_out
        self.q_out_lock = q_out_lock

    def run ( self ):
        print( 'Sender thread is running' )

        while True:
            # Check to see if we should kill thread
            if self.isInterruptionRequested():
                break

            self.q_out_lock.lock()
            if not self.q_out.empty():
                container = self.q_out.get()
                self.q_out_lock.unlock()
                data = container.SerializeToString()
                try:
                    self.s_lock.lock()
                    self.s.sendall( data )
                    time.sleep( 0.05 )

                except ( ConnectionAbortedError, ConnectionResetError, ConnectionRefusedError ):
                    self.lost_conn.emit()
                    break

                finally:
                    self.s_lock.unlock()
            else:
                self.q_out_lock.unlock()

        print( 'Sender thread shutting down' )
############################################################################################


############################################################################################
# Thread that handles receiving
class Receiver ( QtCore.QThread ):
    lost_conn = QtCore.pyqtSignal()
    server_alive = QtCore.pyqtSignal()

    def __init__ ( self, s, s_lock, q_in, q_in_lock ):
        QtCore.QThread.__init__( self )
        self.s = s
        self.s_lock = s_lock
        self.q_in = q_in
        self.q_in_lock = q_in_lock

    def run ( self ):
        print( 'Receiver thread is running' )

        while True:
            # Check to see if we should kill thread
            if self.isInterruptionRequested():
                break

            try:
                self.s_lock.lock()
                data = self.s.recv( 1024 )
                if data:
                    try:
                        container = tool_shed.container()
                        container.ParseFromString( data )
                        self.server_alive.emit()
                        self.q_in_lock.lock()
                        self.q_in.put( container )
                        self.q_in_lock.unlock()

                    except DecodeError:
                        print( 'Was not able to parse message!' )

            except BlockingIOError:
                continue

            except ( ConnectionAbortedError, ConnectionResetError, ConnectionRefusedError ):
                self.lost_conn.emit()
                break

            finally:
                self.s_lock.unlock()

        print( 'Receiver thread shutting down' )
############################################################################################


#######################################################################################################
# Create QtThread that will update the GUI
class UpdateMonitor ( QtCore.QThread ):
    device_update_signal = QtCore.pyqtSignal( [ int, bool ] )
    print_info_signal = QtCore.pyqtSignal( [ str ] )
    save_schedule = QtCore.pyqtSignal( [ list ] )

    def __init__ ( self, q_in, q_in_lock ):
        QtCore.QThread.__init__( self )
        self.q_in = q_in
        self.q_in_lock = q_in_lock

    def run ( self ):
        print( 'Updater monitor thread is running' )

        while True:
            # Check to see if we should kill thread
            if self.isInterruptionRequested():
                break

            self.q_in_lock.lock()
            if not self.q_in.empty():
                container = self.q_in.get()
                self.q_in_lock.unlock()
                
                if container.HasField( 'all_device_updates' ):
                    for dev_update in container.all_device_updates.updates:
                        self.device_update_signal.emit( dev_update.device, dev_update.status )

                elif container.HasField( 'all_watering_times' ):
                    watering_times = [ x for x in container.all_watering_times.times ]
                    watering_times.sort( key=lambda x:x.timestamp.seconds )
                    self.save_schedule.emit( watering_times )

                elif container.HasField( 'no_watering_times' ):
                    self.save_schedule.emit( [] )

                elif container.HasField( 'logs' ):
                    if container.logs == '':
                        self.print_info_signal.emit( 'No logs!' )
                    else:
                        self.print_info_signal.emit( 'LOGS:' )
                        self.print_info_signal.emit( container.logs[ :-1 ] )

            else:
                self.q_in_lock.unlock()

        print( 'The update monitor thread is shutting down' )
#######################################################################################################


############################################################
# Clickable label, used for secret demo mode sensor toggling
class QClickableLabel( QtWidgets.QLabel ):
    clicked = QtCore.pyqtSignal()

    def __init__ ( self, parent ):
        QtWidgets.QLabel.__init__( self, parent )

    def mousePressEvent( self, event ):
        self.clicked.emit()
############################################################


#########################################################################################################
# Table model to use in day schedule
class TableModel( QtCore.QAbstractTableModel ):
    def __init__ ( self, dt, schedule ):
        QtCore.QAbstractTableModel.__init__( self )
        self.dt = dt
        self.schedule = schedule.copy()
        self.table = []
        dt_today = datetime.today()
        dt_clicked = self.dt
        dt_clicked_date = dt_clicked.date()
        self.table = list( [ [ datetime.fromtimestamp( x.timestamp.seconds ).time(), x.duration.seconds // 60, x.period.seconds // 86400 ] for x in is_watering_scheduled( dt_clicked_date, self.schedule )[0] ] )

        self.table.sort()

        self.horizontalHeaders = [''] * 3
        self.setHeaderData( 0, QtCore.Qt.Orientation.Horizontal, 'TIME' )
        self.setHeaderData( 1, QtCore.Qt.Orientation.Horizontal, 'DURATION' )
        self.setHeaderData( 2, QtCore.Qt.Orientation.Horizontal, 'PERIOD' )

    def data ( self, index, role ):
        if role == QtCore.Qt.ItemDataRole.DisplayRole:
            if index.column() == 0:
                return str( self.table[ index.row() ][ index.column() ].strftime( '%H:%M' ) )
            elif index.column() == 1:
                return str( self.table[ index.row() ][ index.column() ] ) + ' mins'
            elif index.column() == 2:
                return str( self.table[ index.row() ][ index.column() ] ) + ' days'
            else:
                return str( self.table[ index.row() ][ index.column() ] )
        elif role == QtCore.Qt.ItemDataRole.EditRole:
            return self.table[ index.row() ][ index.column() ]

    def rowCount( self, index ):
        return len( self.table ) if self.table else 0

    def columnCount( self, index ):
        return len( self.table[0] ) if self.table else 0

    def setHeaderData(self, section, orientation, data, role=QtCore.Qt.ItemDataRole.EditRole):
        if orientation == QtCore.Qt.Orientation.Horizontal and role in (QtCore.Qt.ItemDataRole.DisplayRole, QtCore.Qt.ItemDataRole.EditRole):
            try:
                self.horizontalHeaders[section] = data
                return True
            except:
                return False
        return super().setHeaderData(section, orientation, data, role)

    def headerData(self, section, orientation, role=QtCore.Qt.ItemDataRole.DisplayRole):
        if orientation == QtCore.Qt.Orientation.Horizontal and role == QtCore.Qt.ItemDataRole.DisplayRole:
            try:
                return self.horizontalHeaders[section]
            except:
                pass
        return super().headerData(section, orientation, role)
#########################################################################################################


###################################################
# Wrap day schedule
class DaySchedule ( QtWidgets.QDialog ):
    send_signal = QtCore.pyqtSignal( [ tool_shed.container ] )
    schedule = []

    def __init__ ( self, parent=None, schedule=None, dt=None ):
        QtWidgets.QDialog.__init__( self, parent )
        self.ui = Ui_DaySchedule()
        self.ui.setupUi( self )
        self.schedule = schedule.copy()
        self.dt = dt
        self.model = TableModel( self.dt, self.schedule )
        self.ui.tv_day_sched.setModel( self.model )
        self.ui.tv_day_sched.doubleClicked.connect( self.copy_from_cell )
        self.ui.btn_sched.clicked.connect( self.schedule_watering )
        self.ui.btn_unsched.clicked.connect( self.unschedule_watering )

    def schedule_watering ( self ):
        period = self.ui.hs_period.value()
        duration = self.ui.hs_dur.value()
        time = self.ui.te_d_tod.time()
        dt = datetime( year=self.dt.year, month=self.dt.month, day=self.dt.day, hour=time.hour(), minute=time.minute() )
        td_dur = timedelta( minutes=duration )
        td_period = timedelta( days=period )
        container = tool_shed.container()
        container.set_watering_time.timestamp.seconds = int( dt.timestamp() )
        container.set_watering_time.duration.FromTimedelta( td_dur )
        container.set_watering_time.period.FromTimedelta( td_period )
        self.send_signal.emit( container )
        container = tool_shed.container()
        container.get_watering_times = 1
        self.send_signal.emit( container )

    def unschedule_watering ( self ):
        period = self.ui.hs_period.value()
        duration = self.ui.hs_dur.value()
        time = self.ui.te_d_tod.time()
        dt = datetime( year=self.dt.year, month=self.dt.month, day=self.dt.day, hour=time.hour(), minute=time.minute() )
        td_dur = timedelta( minutes=duration )
        td_period = timedelta( days=period )
        container = tool_shed.container()
        container.cancel_watering_time.timestamp.seconds = int( dt.timestamp() )
        container.cancel_watering_time.duration.FromTimedelta( td_dur )
        container.cancel_watering_time.period.FromTimedelta( td_period )
        self.send_signal.emit( container )
        container = tool_shed.container()
        container.get_watering_times = 1
        self.send_signal.emit( container )

    def set_schedule ( self, schedule ):
        self.schedule = schedule.copy()
        self.model = TableModel( self.dt, self.schedule )
        self.ui.tv_day_sched.setModel( self.model )

    def copy_from_cell ( self, index ):
        time = self.model.table[ index.row() ][ 0 ]
        time = QtCore.QTime( time.hour, time.minute )
        self.ui.te_d_tod.setTime( time )
        dur = self.model.table[ index.row() ][ 1 ]
        self.ui.hs_dur.setValue( dur )
        period = self.model.table[ index.row() ][ 2 ]
        self.ui.hs_period.setValue( period )
###################################################


############################################################################################
# Paintable label, used for painting days that have events
class QPaintableCalendarWidget( QtWidgets.QCalendarWidget ):
    print_info_signal = QtCore.pyqtSignal( [ str ] )
    schedule = []

    def __init__ ( self, parent ):
        QtWidgets.QCalendarWidget.__init__( self, parent )

    def set_schedule ( self, schedule ):
        self.schedule = schedule.copy()
        self.updateCells()

    def paintCell ( self, painter, rect, date ):
        dt_today = datetime.today()
        dt_painting = datetime( year=date.year(), month=date.month(), day=date.day() )
        dt_painting_date = dt_painting.date()
        super().paintCell( painter, rect, date )
        bg_color = QtGui.QColor( 'blue' )
        bg_color.setAlpha( 64 )
        bg_color_dark = QtGui.QColor( 'darkBlue' )
        bg_color_dark.setAlpha( 128 )
        found_watering_times, origin = is_watering_scheduled( dt_painting_date, self.schedule )
        if found_watering_times:
            painter.save()
            painter.fillRect( rect, bg_color_dark if origin else bg_color )
            font = painter.font()
            font.setPointSize( 5 * font.pointSize() // 6 )
            font.setBold( True )
            font.setItalic( True )
            painter.setFont( font )
            painter.drawText( rect, 0, 'x' + str( len( found_watering_times ) ) )
            painter.restore()
############################################################################################


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(600, 720)
        MainWindow.setTabShape(QtWidgets.QTabWidget.TabShape.Triangular)
        MainWindow.setUnifiedTitleAndToolBarOnMac(True)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())
        self.centralwidget.setSizePolicy(sizePolicy)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_4.setSizeConstraint(QtWidgets.QLayout.SizeConstraint.SetDefaultConstraint)
        self.gridLayout_4.setObjectName("gridLayout_4")
        self.widget_controls = QtWidgets.QWidget(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Maximum, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_controls.sizePolicy().hasHeightForWidth())
        self.widget_controls.setSizePolicy(sizePolicy)
        self.widget_controls.setObjectName("widget_controls")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.widget_controls)
        self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.gb_connection = QtWidgets.QGroupBox(parent=self.widget_controls)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.gb_connection.sizePolicy().hasHeightForWidth())
        self.gb_connection.setSizePolicy(sizePolicy)
        self.gb_connection.setObjectName("gb_connection")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.gb_connection)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.lbl_host = QtWidgets.QLabel(parent=self.gb_connection)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lbl_host.sizePolicy().hasHeightForWidth())
        self.lbl_host.setSizePolicy(sizePolicy)
        self.lbl_host.setObjectName("lbl_host")
        self.gridLayout_2.addWidget(self.lbl_host, 0, 1, 1, 1)
        self.lbl_port = QtWidgets.QLabel(parent=self.gb_connection)
        self.lbl_port.setObjectName("lbl_port")
        self.gridLayout_2.addWidget(self.lbl_port, 2, 1, 1, 1)
        self.txt_port = QtWidgets.QLineEdit(parent=self.gb_connection)
        self.txt_port.setMaximumSize(QtCore.QSize(100, 16777215))
        self.txt_port.setObjectName("txt_port")
        self.gridLayout_2.addWidget(self.txt_port, 2, 2, 1, 1)
        self.txt_host = QtWidgets.QLineEdit(parent=self.gb_connection)
        self.txt_host.setMaximumSize(QtCore.QSize(100, 16777215))
        self.txt_host.setText("")
        self.txt_host.setObjectName("txt_host")
        self.gridLayout_2.addWidget(self.txt_host, 0, 2, 1, 1)
        self.btn_connect = QtWidgets.QPushButton(parent=self.gb_connection)
        self.btn_connect.setEnabled(True)
        self.btn_connect.setObjectName("btn_connect")
        self.gridLayout_2.addWidget(self.btn_connect, 3, 1, 1, 2)
        self.verticalLayout_3.addWidget(self.gb_connection)
        self.gb_watering = QtWidgets.QGroupBox(parent=self.widget_controls)
        self.gb_watering.setObjectName("gb_watering")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.gb_watering)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.btn_get_sched = QtWidgets.QPushButton(parent=self.gb_watering)
        self.btn_get_sched.setObjectName("btn_get_sched")
        self.verticalLayout_2.addWidget(self.btn_get_sched)
        self.widget_3 = QtWidgets.QWidget(parent=self.gb_watering)
        self.widget_3.setObjectName("widget_3")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.widget_3)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.lbl_water_dur = QtWidgets.QLabel(parent=self.widget_3)
        self.lbl_water_dur.setObjectName("lbl_water_dur")
        self.horizontalLayout_2.addWidget(self.lbl_water_dur)
        self.sb_water_dur = QtWidgets.QSpinBox(parent=self.widget_3)
        self.sb_water_dur.setMinimum(1)
        self.sb_water_dur.setObjectName("sb_water_dur")
        self.horizontalLayout_2.addWidget(self.sb_water_dur)
        self.lbl_water_dur_units = QtWidgets.QLabel(parent=self.widget_3)
        self.lbl_water_dur_units.setObjectName("lbl_water_dur_units")
        self.horizontalLayout_2.addWidget(self.lbl_water_dur_units)
        self.cb_water_dur = QtWidgets.QCheckBox(parent=self.widget_3)
        self.cb_water_dur.setText("")
        self.cb_water_dur.setChecked(False)
        self.cb_water_dur.setObjectName("cb_water_dur")
        self.horizontalLayout_2.addWidget(self.cb_water_dur)
        self.verticalLayout_2.addWidget(self.widget_3)
        self.btn_start_water = QtWidgets.QPushButton(parent=self.gb_watering)
        self.btn_start_water.setObjectName("btn_start_water")
        self.verticalLayout_2.addWidget(self.btn_start_water)
        self.btn_stop_water = QtWidgets.QPushButton(parent=self.gb_watering)
        self.btn_stop_water.setObjectName("btn_stop_water")
        self.verticalLayout_2.addWidget(self.btn_stop_water)
        self.verticalLayout_3.addWidget(self.gb_watering)
        self.gb_pumping = QtWidgets.QGroupBox(parent=self.widget_controls)
        self.gb_pumping.setObjectName("gb_pumping")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.gb_pumping)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.widget_4 = QtWidgets.QWidget(parent=self.gb_pumping)
        self.widget_4.setObjectName("widget_4")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout(self.widget_4)
        self.horizontalLayout_4.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.lbl_pump_dur = QtWidgets.QLabel(parent=self.widget_4)
        self.lbl_pump_dur.setObjectName("lbl_pump_dur")
        self.horizontalLayout_4.addWidget(self.lbl_pump_dur)
        self.sb_pump_dur = QtWidgets.QSpinBox(parent=self.widget_4)
        self.sb_pump_dur.setMinimum(1)
        self.sb_pump_dur.setProperty("value", 1)
        self.sb_pump_dur.setObjectName("sb_pump_dur")
        self.horizontalLayout_4.addWidget(self.sb_pump_dur)
        self.lbl_pump_dur_units = QtWidgets.QLabel(parent=self.widget_4)
        self.lbl_pump_dur_units.setObjectName("lbl_pump_dur_units")
        self.horizontalLayout_4.addWidget(self.lbl_pump_dur_units)
        self.cb_pump_dur = QtWidgets.QCheckBox(parent=self.widget_4)
        self.cb_pump_dur.setText("")
        self.cb_pump_dur.setChecked(False)
        self.cb_pump_dur.setObjectName("cb_pump_dur")
        self.horizontalLayout_4.addWidget(self.cb_pump_dur)
        self.verticalLayout_5.addWidget(self.widget_4)
        self.btn_start_pump = QtWidgets.QPushButton(parent=self.gb_pumping)
        self.btn_start_pump.setObjectName("btn_start_pump")
        self.verticalLayout_5.addWidget(self.btn_start_pump)
        self.btn_stop_pump = QtWidgets.QPushButton(parent=self.gb_pumping)
        self.btn_stop_pump.setObjectName("btn_stop_pump")
        self.verticalLayout_5.addWidget(self.btn_stop_pump)
        self.verticalLayout_3.addWidget(self.gb_pumping)
        self.gb_misc = QtWidgets.QGroupBox(parent=self.widget_controls)
        self.gb_misc.setObjectName("gb_misc")
        self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.gb_misc)
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.btn_log = QtWidgets.QPushButton(parent=self.gb_misc)
        self.btn_log.setObjectName("btn_log")
        self.verticalLayout_8.addWidget(self.btn_log)
        self.btn_about = QtWidgets.QPushButton(parent=self.gb_misc)
        self.btn_about.setObjectName("btn_about")
        self.verticalLayout_8.addWidget(self.btn_about)
        self.verticalLayout_3.addWidget(self.gb_misc)
        self.gridLayout_4.addWidget(self.widget_controls, 0, 0, 1, 1)
        self.widget_status = QtWidgets.QWidget(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_status.sizePolicy().hasHeightForWidth())
        self.widget_status.setSizePolicy(sizePolicy)
        self.widget_status.setObjectName("widget_status")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.widget_status)
        self.verticalLayout_6.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.gb_status = QtWidgets.QGroupBox(parent=self.widget_status)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.gb_status.sizePolicy().hasHeightForWidth())
        self.gb_status.setSizePolicy(sizePolicy)
        self.gb_status.setObjectName("gb_status")
        self.gridLayout = QtWidgets.QGridLayout(self.gb_status)
        self.gridLayout.setObjectName("gridLayout")
        self.widget = QtWidgets.QWidget(parent=self.gb_status)
        self.widget.setObjectName("widget")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.widget)
        self.gridLayout_3.setContentsMargins(0, 0, 0, -1)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.lbl_tank_empty = QtWidgets.QLabel(parent=self.widget)
        self.lbl_tank_empty.setObjectName("lbl_tank_empty")
        self.gridLayout_3.addWidget(self.lbl_tank_empty, 6, 0, 1, 1)
        self.lbl_pump_status_disp = QtWidgets.QLabel(parent=self.widget)
        self.lbl_pump_status_disp.setMinimumSize(QtCore.QSize(50, 0))
        self.lbl_pump_status_disp.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.lbl_pump_status_disp.setObjectName("lbl_pump_status_disp")
        self.gridLayout_3.addWidget(self.lbl_pump_status_disp, 0, 1, 1, 1)
        self.line_4 = QtWidgets.QFrame(parent=self.widget)
        self.line_4.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_4.setObjectName("line_4")
        self.gridLayout_3.addWidget(self.line_4, 7, 0, 1, 2)
        self.lbl_valve_status = QtWidgets.QLabel(parent=self.widget)
        self.lbl_valve_status.setObjectName("lbl_valve_status")
        self.gridLayout_3.addWidget(self.lbl_valve_status, 2, 0, 1, 1)
        self.lbl_tank_empty_disp = QClickableLabel(parent=self.widget)
        self.lbl_tank_empty_disp.setMinimumSize(QtCore.QSize(50, 0))
        self.lbl_tank_empty_disp.setObjectName("lbl_tank_empty_disp")
        self.gridLayout_3.addWidget(self.lbl_tank_empty_disp, 6, 1, 1, 1)
        self.lbl_tank_full = QtWidgets.QLabel(parent=self.widget)
        self.lbl_tank_full.setObjectName("lbl_tank_full")
        self.gridLayout_3.addWidget(self.lbl_tank_full, 4, 0, 1, 1)
        self.line = QtWidgets.QFrame(parent=self.widget)
        self.line.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line.setObjectName("line")
        self.gridLayout_3.addWidget(self.line, 1, 0, 1, 2)
        self.lbl_tank_full_disp = QClickableLabel(parent=self.widget)
        self.lbl_tank_full_disp.setMinimumSize(QtCore.QSize(50, 0))
        self.lbl_tank_full_disp.setObjectName("lbl_tank_full_disp")
        self.gridLayout_3.addWidget(self.lbl_tank_full_disp, 4, 1, 1, 1)
        self.line_3 = QtWidgets.QFrame(parent=self.widget)
        self.line_3.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_3.setObjectName("line_3")
        self.gridLayout_3.addWidget(self.line_3, 5, 0, 1, 2)
        self.lbl_rain_disp = QClickableLabel(parent=self.widget)
        self.lbl_rain_disp.setMinimumSize(QtCore.QSize(50, 0))
        self.lbl_rain_disp.setObjectName("lbl_rain_disp")
        self.gridLayout_3.addWidget(self.lbl_rain_disp, 10, 1, 1, 1)
        self.lbl_well_empty_disp = QClickableLabel(parent=self.widget)
        self.lbl_well_empty_disp.setMinimumSize(QtCore.QSize(50, 0))
        self.lbl_well_empty_disp.setObjectName("lbl_well_empty_disp")
        self.gridLayout_3.addWidget(self.lbl_well_empty_disp, 8, 1, 1, 1)
        self.lbl_well_empty = QtWidgets.QLabel(parent=self.widget)
        self.lbl_well_empty.setObjectName("lbl_well_empty")
        self.gridLayout_3.addWidget(self.lbl_well_empty, 8, 0, 1, 1)
        self.lbl_valve_status_disp = QtWidgets.QLabel(parent=self.widget)
        self.lbl_valve_status_disp.setMinimumSize(QtCore.QSize(50, 0))
        self.lbl_valve_status_disp.setObjectName("lbl_valve_status_disp")
        self.gridLayout_3.addWidget(self.lbl_valve_status_disp, 2, 1, 1, 1)
        self.line_2 = QtWidgets.QFrame(parent=self.widget)
        self.line_2.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_2.setObjectName("line_2")
        self.gridLayout_3.addWidget(self.line_2, 3, 0, 1, 2)
        self.lbl_pump_status = QtWidgets.QLabel(parent=self.widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Maximum, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lbl_pump_status.sizePolicy().hasHeightForWidth())
        self.lbl_pump_status.setSizePolicy(sizePolicy)
        self.lbl_pump_status.setObjectName("lbl_pump_status")
        self.gridLayout_3.addWidget(self.lbl_pump_status, 0, 0, 1, 1)
        self.lbl_rain = QtWidgets.QLabel(parent=self.widget)
        self.lbl_rain.setObjectName("lbl_rain")
        self.gridLayout_3.addWidget(self.lbl_rain, 10, 0, 1, 1)
        self.line_5 = QtWidgets.QFrame(parent=self.widget)
        self.line_5.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line_5.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_5.setObjectName("line_5")
        self.gridLayout_3.addWidget(self.line_5, 9, 0, 1, 2)
        self.gridLayout.addWidget(self.widget, 1, 0, 1, 1)
        self.verticalLayout_6.addWidget(self.gb_status)
        self.gb_calendar = QtWidgets.QGroupBox(parent=self.widget_status)
        self.gb_calendar.setObjectName("gb_calendar")
        self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.gb_calendar)
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.cw_schedule = QPaintableCalendarWidget(parent=self.gb_calendar)
        self.cw_schedule.setGridVisible(True)
        self.cw_schedule.setHorizontalHeaderFormat(QtWidgets.QCalendarWidget.HorizontalHeaderFormat.ShortDayNames)
        self.cw_schedule.setVerticalHeaderFormat(QtWidgets.QCalendarWidget.VerticalHeaderFormat.NoVerticalHeader)
        self.cw_schedule.setNavigationBarVisible(True)
        self.cw_schedule.setDateEditEnabled(False)
        self.cw_schedule.setObjectName("cw_schedule")
        self.verticalLayout_9.addWidget(self.cw_schedule)
        self.verticalLayout_6.addWidget(self.gb_calendar)
        self.gridLayout_4.addWidget(self.widget_status, 0, 1, 1, 1)
        self.gb_output = QtWidgets.QGroupBox(parent=self.centralwidget)
        self.gb_output.setObjectName("gb_output")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.gb_output)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.scrollArea = QtWidgets.QScrollArea(parent=self.gb_output)
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName("scrollArea")
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 584, 143))
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
        self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.scrollAreaWidgetContents)
        self.verticalLayout_7.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.text_output = QtWidgets.QTextEdit(parent=self.scrollAreaWidgetContents)
        self.text_output.setReadOnly(True)
        self.text_output.setObjectName("text_output")
        self.verticalLayout_7.addWidget(self.text_output)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.verticalLayout.addWidget(self.scrollArea)
        self.gridLayout_4.addWidget(self.gb_output, 1, 0, 1, 2)
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        # Create palettes used to color labels
        self.green = QtGui.QPalette()
        self.green.setColor( QtGui.QPalette.ColorRole.WindowText, QtGui.QColor( 'green' ) )
        self.red = QtGui.QPalette()
        self.red.setColor( QtGui.QPalette.ColorRole.WindowText, QtGui.QColor( 'red' ) )

        # Set up device to widget map
        self.dev_map = {
            tool_shed.container.devices.DEV_ACT_PUMP: ( self.lbl_pump_status, self.lbl_pump_status_disp ),
            tool_shed.container.devices.DEV_ACT_VALVE: ( self.lbl_valve_status, self.lbl_valve_status_disp ),
            tool_shed.container.devices.DEV_SNS_TANK_FULL: ( self.lbl_tank_full, self.lbl_tank_full_disp ),
            tool_shed.container.devices.DEV_SNS_TANK_EMPTY: ( self.lbl_tank_empty, self.lbl_tank_empty_disp ),
            tool_shed.container.devices.DEV_SNS_WELL_EMPTY: ( self.lbl_well_empty, self.lbl_well_empty_disp ),
            tool_shed.container.devices.DEV_SNS_RAIN: ( self.lbl_rain, self.lbl_rain_disp ),
        }

        # Set the HOST and PORT default text
        self.txt_host.setText( HOST )
        self.txt_port.setText( str( PORT ) )

        # Connect host and port to connect on enter
        self.txt_host.returnPressed.connect( self.connect )
        self.txt_port.returnPressed.connect( self.connect )

        # Disable the control interfaces until we have a connection
        self.gb_watering.setEnabled( False )
        self.gb_pumping.setEnabled( False )
        self.gb_status.setEnabled( False )
        self.gb_calendar.setEnabled( False )
        self.btn_log.setEnabled( False )

        # Set up queues and queue locks
        self.q_in = queue.Queue()
        self.q_in_lock = QtCore.QMutex()
        self.q_out = queue.Queue()
        self.q_out_lock = QtCore.QMutex()

        # Create comm lock
        self.s_lock = QtCore.QMutex()

        # Set up thread to signal updates to GUI
        self.updater = UpdateMonitor( self.q_in, self.q_in_lock )
        self.updater.device_update_signal.connect( self.device_update )
        self.updater.print_info_signal.connect( self.text_output.append )
        self.updater.save_schedule.connect( self.save_schedule )
        self.updater.start()

        # Connect connect button to slot
        self.btn_connect.pressed.connect( self.connect )

        # Connect about button to slot
        self.btn_about.pressed.connect( self.about )

        # Connect get schedule button to slot
        self.btn_get_sched.pressed.connect( self.print_schedule )

        # Connect start watering button to slot
        self.btn_start_water.pressed.connect( self.start_watering )

        # Connect stop watering button to slot
        self.btn_stop_water.pressed.connect( self.stop_watering )

        # Connect start pumping button to slot
        self.btn_start_pump.pressed.connect( self.start_pumping )

        # Connect stop pumping button to slot
        self.btn_stop_pump.pressed.connect( self.stop_pumping )

        # Connect peak event log button to slot
        self.btn_log.pressed.connect( self.peak_event_log )

        # Connect calendar signals
        self.cw_schedule.activated.connect( self.day_schedule_popup )
        self.cw_schedule.print_info_signal.connect( self.text_output.append )

        # Set background color of navigation bar of calendar
        self.cw_schedule.setStyleSheet( "QCalendarWidget  QWidget#qt_calendar_navigationbar"
                                        "{"
                                        "background-color : darkGray;"
                                        "}"
                                        "QCalendarWidget  QWidget# qt_calendar_navigationbar::hover"
                                        "{"
                                        "background-color : darkGray;"
                                        "}" )

        # Initialize popup to None
        self.popup = None

        # Initialize schedule to None
        self.schedule = None

        # Hook up sensor overrides if demo mode
        if DEMO_MODE:
            self.lbl_tank_full_disp.clicked.connect( lambda: self.toggle_sensor( tool_shed.container.devices.DEV_SNS_TANK_FULL, self.lbl_tank_full_disp ) )
            self.lbl_tank_empty_disp.clicked.connect( lambda: self.toggle_sensor( tool_shed.container.devices.DEV_SNS_TANK_EMPTY, self.lbl_tank_empty_disp ) )
            self.lbl_well_empty_disp.clicked.connect( lambda: self.toggle_sensor( tool_shed.container.devices.DEV_SNS_WELL_EMPTY, self.lbl_well_empty_disp ) )
            self.lbl_rain_disp.clicked.connect( lambda: self.toggle_sensor( tool_shed.container.devices.DEV_SNS_RAIN, self.lbl_rain_disp ) )

        self.about()

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Remote Gardener"))
        self.gb_connection.setTitle(_translate("MainWindow", "Connection"))
        self.lbl_host.setText(_translate("MainWindow", "Host:"))
        self.lbl_port.setText(_translate("MainWindow", "Port:"))
        self.btn_connect.setText(_translate("MainWindow", "Connect"))
        self.gb_watering.setTitle(_translate("MainWindow", "Watering"))
        self.btn_get_sched.setText(_translate("MainWindow", "Print Schedule"))
        self.lbl_water_dur.setText(_translate("MainWindow", "Duration"))
        self.lbl_water_dur_units.setText(_translate("MainWindow", "min"))
        self.btn_start_water.setText(_translate("MainWindow", "Start"))
        self.btn_stop_water.setText(_translate("MainWindow", "Stop"))
        self.gb_pumping.setTitle(_translate("MainWindow", "Pumping"))
        self.lbl_pump_dur.setText(_translate("MainWindow", "Duration"))
        self.lbl_pump_dur_units.setText(_translate("MainWindow", "min"))
        self.btn_start_pump.setText(_translate("MainWindow", "Start"))
        self.btn_stop_pump.setText(_translate("MainWindow", "Stop"))
        self.gb_misc.setTitle(_translate("MainWindow", "Miscellaneous"))
        self.btn_log.setText(_translate("MainWindow", "Peak Event Log"))
        self.btn_about.setText(_translate("MainWindow", "About"))
        self.gb_status.setTitle(_translate("MainWindow", "Status"))
        self.lbl_tank_empty.setText(_translate("MainWindow", "Tank empty sensor status:"))
        self.lbl_pump_status_disp.setText(_translate("MainWindow", "UNKNOWN"))
        self.lbl_valve_status.setText(_translate("MainWindow", "Valve status:"))
        self.lbl_tank_empty_disp.setText(_translate("MainWindow", "UNKNOWN"))
        self.lbl_tank_full.setText(_translate("MainWindow", "Tank full sensor status:"))
        self.lbl_tank_full_disp.setText(_translate("MainWindow", "UNKNOWN"))
        self.lbl_rain_disp.setText(_translate("MainWindow", "UNKNOWN"))
        self.lbl_well_empty_disp.setText(_translate("MainWindow", "UNKNOWN"))
        self.lbl_well_empty.setText(_translate("MainWindow", "Well empty sensor status:"))
        self.lbl_valve_status_disp.setText(_translate("MainWindow", "UNKNOWN"))
        self.lbl_pump_status.setText(_translate("MainWindow", "Pump status:"))
        self.lbl_rain.setText(_translate("MainWindow", "Rain sensor status:"))
        self.gb_calendar.setTitle(_translate("MainWindow", "Schedule"))
        self.gb_output.setTitle(_translate("MainWindow", "Output"))

    def device_update ( self, device, status ):
        self.dev_map[ device ][ 1 ].setText( 'ACTIVE' if status else 'INACTIVE' )
        if status:
            self.dev_map[ device ][ 1 ].setPalette( self.green )
        else:
            self.dev_map[ device ][ 1 ].setPalette( self.red )

    def connect ( self ):
        try:
            host = self.txt_host.text()
            port = int( self.txt_port.text() )
            self.s = socket.socket( socket.AF_INET, socket.SOCK_STREAM )
            self.s.settimeout( 0.5 )
            self.s.connect( ( host, port ) )
            self.s.settimeout( None )
            self.s.setblocking( 0 )

            # Create comm threads
            self.sender = Sender( self.s, self.s_lock, self.q_out, self.q_out_lock )
            self.receiver = Receiver( self.s, self.s_lock, self.q_in, self.q_in_lock )
            self.heartbeat = QtCore.QTimer()
            self.pulse_mon = QtCore.QTimer()
            self.pulse_mon.setSingleShot( True )

            # Connect signals for threads
            self.sender.lost_conn.connect( self.disconnect )
            self.receiver.lost_conn.connect( self.disconnect )
            self.receiver.server_alive.connect( self.postpone_pulse_mon )
            self.heartbeat.timeout.connect( self.get_device_updates )
            self.heartbeat.timeout.connect( self.get_schedule )
            self.pulse_mon.timeout.connect( self.disconnect )

            # Start comms threads
            self.sender.start()
            self.receiver.start()
            self.heartbeat.start( 250 )
            self.pulse_mon.start( 5000 )

            # If none of that raised an exception then we connected
            self.gb_connection.setEnabled( False )
            self.gb_watering.setEnabled( True )
            self.gb_pumping.setEnabled( True )
            self.gb_status.setEnabled( True )
            self.gb_calendar.setEnabled( True )
            self.btn_log.setEnabled( True )
            if self.popup:
                self.popup.setEnabled( True )

            # Get device updates
            self.get_device_updates()

            # Get watering schedule
            self.get_schedule()

        except ValueError:
            self.text_output.append( 'Port is not an integer' )

        except TimeoutError:
            self.text_output.append( 'Failed to connect to host' )

        except ConnectionRefusedError:
            self.text_output.append( 'Connection was refused' )

        except socket.gaierror as e:
            self.text_output.append( str( e ) )

    def disconnect ( self ):
        # Stop timers
        self.heartbeat.stop()

        # Request comms threads stop
        self.sender.requestInterruption()
        self.receiver.requestInterruption()

        # Wait until they have stopped
        self.sender.wait()
        self.receiver.wait()

        # Disabled the interfaces for the gardener and re-enable the connection menu
        self.gb_connection.setEnabled( True )
        self.gb_watering.setEnabled( False )
        self.gb_pumping.setEnabled( False )
        self.gb_status.setEnabled( False )
        self.gb_calendar.setEnabled( False )
        self.btn_log.setEnabled( False )
        if self.popup:
            self.popup.setEnabled( False )

        # Reset queues
        def empty_queue ( q ):
            while not q.empty():
                try:
                    q.get_nowait()
                except queue.Empty:
                    break
        
        self.q_in_lock.lock()
        empty_queue( self.q_in )
        self.q_in_lock.unlock()
        self.q_out_lock.lock()
        empty_queue( self.q_out )
        self.q_out_lock.unlock()

        # Shutdown and close connection, we
        # don't have to use s_lock because
        # we already joined sender_thread
        self.s.close()

    def about ( self ):
        self.text_output.append( ABOUT_STR )

    def get_device_updates ( self ):
        container = tool_shed.container()
        container.get_device_updates = 1
        self.q_out_enqueue( container )

    def get_schedule ( self ):
        container = tool_shed.container()
        container.get_watering_times = 1
        self.q_out_enqueue( container )

    def start_watering ( self ):
        duration = self.sb_water_dur.value() if self.cb_water_dur.isChecked() else 0
        td = timedelta( minutes=duration )
        container = tool_shed.container()
        container.water_now.duration.FromTimedelta( td )
        self.q_out_enqueue( container )

    def stop_watering ( self ):
        container = tool_shed.container()
        container.stop_watering = 1
        self.q_out_enqueue( container )

    def start_pumping ( self ):
        duration = self.sb_pump_dur.value() if self.cb_pump_dur.isChecked() else 0
        td = timedelta( minutes=duration )
        container = tool_shed.container()
        container.pump_now.duration.FromTimedelta( td )
        self.q_out_enqueue( container )

    def stop_pumping ( self ):
        container = tool_shed.container()
        container.stop_pumping = 1
        self.q_out_enqueue( container )

    def peak_event_log ( self ):
        container = tool_shed.container()
        container.peak_event_log = 10
        self.q_out_enqueue( container )

    def toggle_sensor( self, sensor, lbl ):
        status = None
        if lbl.text() == 'ACTIVE':
            status = False
        elif lbl.text() == 'INACTIVE':
            status = True
        else:
            return
            
        container = tool_shed.container()
        container.sensor_override.device = sensor
        container.sensor_override.status = status
        self.q_out_enqueue( container )

    def save_schedule ( self, schedule ):
        if not are_schedules_same( self.schedule, schedule ):
            self.schedule = schedule.copy()
            self.cw_schedule.set_schedule( schedule )
            if self.popup:
                self.popup.set_schedule( schedule )
            self.print_schedule()
            
    def print_schedule ( self ):
        self.text_output.append( 'WATERING SCHEDULE:' )
        if not self.schedule:
            self.text_output.append( 'No watering times scheduled!' )
        for watering_time in self.schedule:
            dt = datetime.fromtimestamp( watering_time.timestamp.seconds )
            td_dur = timedelta( seconds=watering_time.duration.seconds )
            td_period = timedelta( seconds=watering_time.period.seconds )
            self.text_output.append( 'Watering scheduled for ' + str( td_dur.seconds // 60 ) + ' minute(s) on ' + str( dt ) + ' repeating every ' + str( td_period.days ) + ' day(s)' )

    def q_out_enqueue ( self, container ):
        self.q_out_lock.lock()
        self.q_out.put( container )
        self.q_out_lock.unlock()

    def postpone_pulse_mon ( self ):
        if self.pulse_mon.isActive():
            self.pulse_mon.start( 5000 )

    def day_schedule_popup ( self, date ):
        dt = datetime( year=date.year(), month=date.month(), day=date.day() )
        self.popup = DaySchedule( self.centralwidget, self.cw_schedule.schedule, dt=dt )
        self.popup.setWindowTitle( str( dt.date() ) + ' Schedule' )
        self.popup.send_signal.connect( self.q_out_enqueue )
        self.popup.exec()

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec())
